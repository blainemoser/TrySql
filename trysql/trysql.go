package trysql

import (
	"encoding/json"
	"errors"
	"fmt"
	"os"
	"strconv"
	"strings"
	"sync"
	"time"

	jsonextract "github.com/blainemoser/JsonExtract"
	"github.com/blainemoser/TrySql/configs"
	"github.com/blainemoser/TrySql/docker"
	"github.com/gosuri/uilive"
)

var Testing bool

// This is a warning generated by MySql when a password is passed to a command line invocation.
// The warning is not relevant here since it's a test environment
const securityWarning = "[Warning] Using a password on the command line interface can be insecure."

type TrySql struct {
	docker     *docker.Docker
	image      string
	hash       string
	ReadyState int
	Configs    *configs.Configs
	Details    *jsonextract.JSONExtract
}

func Initialise(args []string) (*TrySql, error) {
	var err error
	if len(args) < 1 {
		args = getArgs()
	}
	confs, err := configs.New(args)
	if err != nil {
		return nil, err
	}
	ts, err := generate(confs)
	if err != nil {
		return nil, err
	}
	fmt.Println("found " + string(ts.DockerVersion()))
	err = ts.provision()
	if err != nil {
		return nil, err
	}
	err = ts.run()
	if err != nil {
		return nil, err
	}
	err = ts.waitForHealthy()
	if err != nil {
		return nil, err
	}
	return ts, nil
}

func generate(configs *configs.Configs) (*TrySql, error) {
	d, err := docker.New(configs)
	if err != nil {
		return nil, err
	}
	ts := &TrySql{
		docker:  d,
		image:   "mysql/mysql-server:" + configs.GetMysqlVersion(),
		Configs: configs,
	}
	err = ts.initDocker()
	if err != nil {
		return nil, err
	}
	return ts, nil
}

func (ts *TrySql) DockerVersion() string {
	return ts.docker.Version
}

func (ts *TrySql) MySQLCommand() string {
	return fmt.Sprintf(
		"mysql -uroot -p%s -h127.0.0.1 -P%s",
		ts.Password(),
		ts.HostPortStr(),
	)
}

func (ts *TrySql) Query(query string, report bool) (string, error) {
	result, err := ts.outputCommandRaw(ts.mysqlArgs(query))
	result = ts.parseQueryResult(result)
	if err != nil {
		errString := strings.Split(err.Error(), "\n")
		errors := make([]string, 0)
		for _, errMessage := range errString {
			if len(errMessage) > 0 && !strings.Contains(errMessage, securityWarning) {
				errors = append(errors, errMessage)
			}
		}
		if report && len(errors) > 0 {
			result = result + strings.Join(errors, " | ")
		}
	}
	return result, nil
}

func (ts *TrySql) GetDetails(details []string) string {
	var property string
	var err error
	err = ts.setInspectData()
	if err != nil {
		return err.Error()
	}
	if len(details) < 1 {
		property, err = ts.getJSON("[0]")
		if err != nil {
			return err.Error()
		}
		return property
	}
	result := make([]string, len(details))
	for i := 0; i < len(details); i++ {
		property, err = ts.getJSON("[0]/" + details[i])
		if err != nil {
			result[i] = fmt.Sprintf("%s:\n%s", details[i], err.Error())
			continue
		}
		result[i] = fmt.Sprintf("%s:\n%s", details[i], property)
	}
	return strings.Join(result, "\n")
}

func (ts *TrySql) getJSON(address string) (string, error) {
	property, err := ts.Details.Extract(address)
	if err != nil {
		return "", err
	}
	js, err := json.MarshalIndent(property, "", "\t")
	if err != nil {
		return "", err
	}
	return string(js), nil
}

func (ts *TrySql) parseQueryResult(result string) string {
	result = strings.Trim(result, "\n")
	splitR := strings.Split(result, "\n")
	results := make([]string, 0)
	for _, res := range splitR {
		if len(res) > 0 && !strings.Contains(res, securityWarning) {
			results = append(results, res)
		}
	}
	return strings.Join(results, " | ")
}

func (ts *TrySql) TearDown() error {
	running, err := ts.containerRunning()
	if !running {
		return nil
	}
	if err != nil {
		return err
	}
	fmt.Println("tearing down")
	err = ts.waitAndWrite(ts.stoppingContainer, "stopping container")
	if err != nil {
		return err
	}
	err = ts.waitAndWrite(ts.removingContainer, "removing container")
	fmt.Println("destroyed")
	return err
}

func (ts *TrySql) Password() string {
	return ts.docker.Password
}

func (ts *TrySql) mysqlArgs(query string) string {
	return fmt.Sprintf(
		"exec TrySql mysql --user=root --password=\"%s\" --execute=\"%s\" --connect-expired-password",
		ts.Password(),
		query,
	)
}

func (ts *TrySql) GetContainerDetails(idOnly bool) string {
	containers, err := ts.ps()
	if err != nil {
		return "something went wrong while trying to get the container's details"
	}
	result, err := ts.findContainer(containers)
	if err != nil {
		return err.Error()
	}
	if !idOnly {
		return result
	}
	ts.filterContainerID(&result)
	return result
}

func (ts *TrySql) setHealthyStatus() error {
	timeout := 0
	wait := time.NewTicker(time.Second)
	status := make(chan bool, 1)
	errLog := make(chan error, 1)
	ts.getHealthStatus(status, errLog)
	for {
		select {
		case err := <-errLog:
			return err
		case <-status:
			return nil
		case <-wait.C:
			timeout += 1
			ts.getHealthStatus(status, errLog)
			if timeout >= 120 {
				return fmt.Errorf("timed out while waiting for container temporary password")
			}
		}
	}
}

func (ts *TrySql) setInspectData() error {
	result, err := ts.outputCommand([]string{"inspect", "TrySql"})
	if err != nil {
		return err
	}
	ts.Details = &jsonextract.JSONExtract{
		RawJSON: strings.Trim(strings.Trim(result, " "), "\n"),
	}
	return nil
}

func (ts *TrySql) getHealthStatus(status chan bool, errorChan chan error) {
	details := ts.GetContainerDetails(false)
	details = strings.ToLower(details)
	if strings.Contains(details, "(health: starting)") {
		return
	}
	if strings.Contains(details, "(healthy)") {
		status <- true
		return
	}
	errorChan <- errors.New("no startup activity on container")
}

func (ts *TrySql) listContainers(all bool) ([]string, error) {
	args := []string{"container", "ls"}
	if all {
		args = append(args, "-al")
	}
	containers, err := ts.outputCommand(args)
	if err != nil {
		return nil, err
	}
	existingContainers := strings.Split(containers, "\n")
	if len(existingContainers) > 0 {
		if strings.Contains(existingContainers[0], "CONTAINER ID") {
			existingContainers = existingContainers[1:]
		}
		return existingContainers, nil
	}

	return []string{}, nil
}

func (ts *TrySql) ps() ([]string, error) {
	containers, err := ts.outputCommand([]string{"ps"})
	if err != nil {
		return nil, err
	}
	runningContainers := strings.Split(containers, "\n")
	if len(runningContainers) > 0 {
		if strings.Contains(runningContainers[0], "CONTAINER ID") {
			runningContainers = runningContainers[1:]
		}
		return runningContainers, nil
	}

	return []string{}, nil
}

func (ts *TrySql) provision() error {
	msg := "pulling up to date image"
	return ts.waitAndWrite(ts.provisioningDocker, msg)
}

func (ts *TrySql) waitForHealthy() error {
	msg := "waiting for container to set up"
	return ts.waitAndWrite(ts.waitingForHealtyStatus, msg)
}

func (ts *TrySql) containerRunning() (bool, error) {
	exists, err := ts.containerExists(false)
	if err != nil {
		return false, err
	}
	if !exists {
		fmt.Println("container does not exist")
		return false, nil
	}
	running, err := ts.isRunning()
	if err != nil {
		return false, err
	}
	if !running {
		fmt.Println("container is not running")
		return false, nil
	}
	return true, nil
}

func (ts *TrySql) run() error {
	running, err := ts.containerExists(false)
	if err != nil {
		return err
	}
	if running {
		return nil
	}
	return ts.runNew()
}

func (ts *TrySql) waitAndWrite(funcInterface interface{}, msg string) error {
	functionCall, ok := (funcInterface).(func(*sync.WaitGroup, chan error))
	if !ok {
		return fmt.Errorf("invalid function provided")
	}
	var err error
	initChan := make(chan error, 1)
	writer := uilive.New() // writer for the first line
	wg := &sync.WaitGroup{}
	writer.Start()
	wg.Add(2)
	go ts.wait(wg, initChan, writer, &err, msg)
	go functionCall(wg, initChan)
	wg.Wait()
	close(initChan)
	fmt.Fprintf(writer, msg+" %s\n", "done")
	writer.Stop()
	return err
}

func (ts *TrySql) initDocker() error {
	return ts.docker.SetVersion()
}

func (ts *TrySql) findContainer(containers []string) (string, error) {
	for _, container := range containers {
		if strings.Contains(container, "TrySql") {
			return container, nil
		}
	}
	return "", errors.New("not found")
}

func (ts *TrySql) containerExists(all bool) (bool, error) {
	containers, err := ts.listContainers(all)
	if err != nil {
		return false, err
	}
	for _, container := range containers {
		if strings.Contains(container, "TrySql") {
			return true, nil
		}
	}
	return false, nil
}

func (ts *TrySql) filterContainerID(containerDetails *string) {
	*containerDetails = strings.ReplaceAll(*containerDetails, "\n", " ")
	*containerDetails = strings.ReplaceAll(*containerDetails, "\t", " ")
	splitC := strings.Split(*containerDetails, " ")
	if len(splitC) < 1 {
		*containerDetails = ""
	}
	*containerDetails = splitC[0]
}

func (ts *TrySql) isRunning() (bool, error) {
	containers, err := ts.ps()
	if err != nil {
		return false, err
	}
	for _, container := range containers {
		if strings.Contains(container, "TrySql") {
			return true, nil
		}
	}
	return false, nil
}

func (ts *TrySql) runNew() error {
	msg := "waiting for container connection"
	return ts.waitAndWrite(ts.settingUpContainer, msg)
}

func (ts *TrySql) wait(wg *sync.WaitGroup, initChan chan error, writer *uilive.Writer, err *error, msg string) {
	timeOut := 0
	updating := []string{"|", "/", "-", "\\"}
	uIndex := 0
	for {
		select {
		case *err = <-initChan:
			wg.Done()
			return
		default:
			fmt.Fprintf(writer, msg+" %s\n", updating[uIndex])
			if timeOut > 900 {
				*err = fmt.Errorf("timed out")
				initChan <- *err
				wg.Done()
				return
			}
			if uIndex == 3 {
				uIndex = 0
			} else {
				uIndex++
			}
			timeOut++
			time.Sleep(time.Millisecond * 200)
		}
	}
}

func (ts *TrySql) settingUpContainer(wg *sync.WaitGroup, initChan chan error) {
	defer wg.Done()
	err := ts.needsCleanup()
	if err != nil {
		initChan <- err
		return
	}
	result, err := ts.outputCommand(ts.getRunCommand())
	ts.hash = result
	ts.ReadyState = 1
	initChan <- err
}

func (ts *TrySql) getRunCommand() []string {
	return []string{
		"run",
		"-d",
		"--expose",
		"3306",
		"-e",
		"MYSQL_ROOT_HOST=%",
		"-e",
		"MYSQL_ROOT_PASSWORD=" + ts.Password(),
		"-p",
		ts.HostPortStr() + ":3306",
		"--name=TrySql",
		ts.image,
	}
}

func (ts *TrySql) HostPortStr() string {
	return strconv.Itoa(ts.docker.HostPort)
}

func (ts *TrySql) needsCleanup() error {
	exists, err := ts.containerExists(true)
	if err != nil {
		return err
	}
	if !exists {
		return nil
	}
	return ts.cleanUp()
}

func (ts *TrySql) cleanUp() error {
	ts.outputCommand([]string{"stop", "TrySql"})
	_, err := ts.outputCommand([]string{"rm", "TrySql"})
	return err
}

func (ts *TrySql) provisioningDocker(wg *sync.WaitGroup, initChan chan error) {
	defer wg.Done()
	_, err := ts.outputCommand([]string{"pull", ts.image})
	initChan <- err
}

func (ts *TrySql) waitingForHealtyStatus(wg *sync.WaitGroup, initChan chan error) {
	defer wg.Done()
	initChan <- ts.setHealthyStatus()
}

func (ts *TrySql) stoppingContainer(wg *sync.WaitGroup, initChan chan error) {
	defer wg.Done()
	_, err := ts.outputCommand([]string{"container", "stop", "TrySql"})
	initChan <- err
}

func (ts *TrySql) removingContainer(wg *sync.WaitGroup, initChan chan error) {
	defer wg.Done()
	_, err := ts.outputCommand([]string{"container", "rm", "TrySql"})
	initChan <- err
}

func (ts *TrySql) outputCommand(args []string) (string, error) {
	result, err := ts.docker.Com().Args(args).Exec()
	if err != nil {
		return "", err
	}
	return result, nil
}

func (ts *TrySql) outputCommandRaw(arg string) (string, error) {
	result, err := ts.docker.Com().ExecRaw(arg)
	if err != nil {
		return "", err
	}
	return result, nil
}

func getArgs() []string {
	if Testing {
		return []string{"-v", "latest"}
	}
	return os.Args[1:]
}
